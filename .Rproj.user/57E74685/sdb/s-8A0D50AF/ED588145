{
    "contents" : "library(shiny)\nlibrary(leaflet)\nlibrary(plyr)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(scales)\nlibrary(markdown)\n\n# Leaflet bindings are a bit slow; for now we'll just sample to compensate\n\nd <- subset(housingData, last.sale.date >= as.Date(\"2011-07-01\") & last.sale.date <= Sys.Date())\nset.seed(100)\nd <- d[sample.int(nrow(d), 10000),]\n\nshinyServer(function(input, output, session) {\n  \n    ## Interactive Map ###########################################\n\n    # Create the map\n    map <- createLeafletMap(session, \"map\")\n  \n    # A reactive expression that returns the set of zips that are\n    # in bounds right now\n    houseInBounds <- reactive({\n        if (is.null(input$map_bounds))\n            return(d[FALSE,])\n        bounds <- input$map_bounds\n        latRng <- range(bounds$north, bounds$south)\n        lngRng <- range(bounds$east, bounds$west)\n    \n        subset(d,\n               latitude >= latRng[1] & latitude <= latRng[2] &\n                   longitude >= lngRng[1] & longitude <= lngRng[2]\n               )\n    })\n  \n    # Pre-assign the breaks we'll need for the two histograms\n\n    priceBreaks <- seq(0, 3000000, 100000)\n    priceSqftBreaks <- seq(0, 1500, 100)\n\n    output$histPrice <- renderPlot({\n    \n        # If no houses are in view, don't plot\n        if (nrow(houseInBounds()) == 0)\n            return(NULL)\n    \n        par(mfrow=c(1,2),oma=c(0,0,0,0),mar=c(4,1,3,0))\n        hist(subset(houseInBounds()$last.sale.price, houseInBounds()$last.sale.price < 3000000),\n             breaks = priceBreaks,\n             main = \"Last Sale Price\\n(visible houses)\",\n             xlab = \"Price\",\n             xlim = c(0, 3000000),\n             col = '#00DD00',\n             border = 'white')\n\n        hist(subset(houseInBounds()$price.sqft, houseInBounds()$price.sqft < 1500),\n             breaks = priceSqftBreaks,\n             main = \"Price / Sq.Ft.\\n(visible houses)\",\n             xlab = \"price/sqft\",\n             xlim = c(0, 1500),\n             col = '#00DD00',\n             border = 'white')\n\n    })\n    \n    output$tSeriesPrice <- renderPlot({\n        # If no houses are in view, don't plot\n        if (nrow(houseInBounds()) == 0)\n            return(NULL)\n    \n        p <- ggplot(data = subset(houseInBounds())) + theme_bw()\n        p <- p + geom_smooth(aes(x = as.Date(last.sale.date), y = last.sale.price, color = home.type))\n        p <- p + scale_x_date(labels = date_format(\"%Y-%m\"))\n        p <- p + scale_y_continuous(labels = dollar)\n        p <- p + scale_color_brewer(palette = \"Set1\", name = \"Type\", labels = c(\"Condo\", \"TH\", \"SFR\", \"Mobile\", \"Multi\"))\n        p <- p + theme(legend.position=\"top\")\n        p <- p + xlab(\"Last Sale Date\") + ylab(\"Last Sale Price\")\n        print(p)\n    })  \n    \n  # session$onFlushed is necessary to work around a bug in the Shiny/Leaflet\n  # integration; without it, the addCircle commands arrive in the browser\n  # before the map is created.\n    session$onFlushed(once=TRUE, function() {\n        \n        paintObs <- observe({\n        colorBy <- input$color\n        sizeBy <- input$size\n\n\n        if (colorBy == \"home.type\") {\n            colors <- brewer.pal(7, \"Set1\")[housingData$home.type]\n        } else {\n            colorData <- housingData[[colorBy]]\n            colors <- brewer.pal(7, \"Spectral\")[cut_number(colorData, 7, labels = FALSE)]\n        }\n        \n        colors <- colors[match(d$redfinUrl, housingData$redfinUrl)]\n      \n    # Clear existing circles before drawing\n        map$clearShapes()\n\n        try(\n\n            map$addCircle(d$latitude, d$longitude,\n                            (d[[sizeBy]] / max(d[[sizeBy]])) * 1000,\n                            as.character(d$redfinUrl),\n                            list(stroke=FALSE, fill=TRUE, fillOpacity=0.4),\n                            list(color = colors)  \n            )\n        )\n#       \n        })\n    \n    # TIL this is necessary in order to prevent the observer from\n    # attempting to write to the websocket after the session is gone.\n        session$onSessionEnded(paintObs$suspend)\n    })\n  \n  # Show a popup at the given location\n    showHousePopup <- function(url, lat, lng) {\n        selectedUrl <- housingData[housingData$redfinUrl == url,]\n        content <- as.character(tagList(\n            tags$strong(HTML(sprintf(\"%s, %s, %s %s\",selectedUrl$address, selectedUrl$city, selectedUrl$state, selectedUrl$zip))), tags$br(),\n            sprintf(\"Home Type: %s\", selectedUrl$home.type), tags$br(),\n            sprintf(\"%s Bd/%s Ba\", selectedUrl$beds, selectedUrl$baths), tags$br(),\n            sprintf(\"Last Sale Price: %s\", dollar(selectedUrl$last.sale.price)), tags$br(),\n            sprintf(\"Square Feet: %s\", selectedUrl$sqft), tags$br(),\n            sprintf(\"Price/SqFt: %s\", round(selectedUrl$price.sqft, 0)), tags$br(),\n            sprintf(\"Last Sale Date: %s\", selectedUrl$last.sale.date), tags$br(),\n            sprintf(selectedUrl$redfinUrl)\n        ))\n        map$showPopup(lat, lng, content)\n\n    }\n\n    # When map is clicked, show a popup with city info\n    clickObs <- observe({\n        map$clearPopups()\n        event <- input$map_shape_click\n        if (is.null(event))\n            return()\n    \n        isolate({\n            showHousePopup(event$id, event$lat, event$lng)\n        })\n    })\n  \n    session$onSessionEnded(clickObs$suspend)\n  \n})\n",
    "created" : 1410677746124.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2154979615",
    "id" : "ED588145",
    "lastKnownWriteTime" : 1410734593,
    "path" : "~/Dropbox/Documents/MOOC/Datasets/Santa-Clara-County-Housing-Explorer/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}